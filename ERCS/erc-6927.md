---
eip: 6927
title: Open IP Protocol
description: Remix NFTs and generate new NFT derivative works
author: Saitama (@saitama2009), Combo <combo@1combo.io>, Luigi <luigi@1combo.io>, Gary <gary.y.mao@gmail.com>, Ansen <anssen712@yahoo.com>
discussions-to: https://ethereum-magicians.org/t/draft-eip-nft-fusing-standard/13959
status: Draft
type: Standards Track
category: ERC
created: 2023-04-23
requires: 165, 721
---

## Abstract

This standard extends the [ERC-721](./eip-721.md) standard, enabling users to fuse two or more NFTs to create a new NFT with customized combination rules. This proposal aims to provide a more interactive and dynamic approach to NFT creation, unlocking new possibilities for NFT use cases and increasing their utility within the Ethereum ecosystem.

## Motivation

The current NFT ecosystem lacks a standardized approach to combine multiple NFTs into a new one. While some projects have implemented custom solutions, these are often ad hoc and project-specific, limiting their interoperability with other NFTs and platforms. This standard aims to create a standardized method for fusing NFTs, enabling users to create new NFTs by combining existing ones according to customizable combination rules. This will foster more incredible innovation and creativity within the NFT space and create new possibilities for NFT use cases.

## Specification

The keywords “MUST,” “MUST NOT,” “REQUIRED,” “SHALL,” “SHALL NOT,” “SHOULD,” “SHOULD NOT,” “RECOMMENDED,” “MAY,” and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

**Interface**

This protocol contains three core modules, fusing module, license module, and network module.

### Fusing

This module extends the existing ERC-721 standard:

```solidity
// SPDX-License-Identifier: CC0-1.0
pragma solidity ^0.8.10;

interface IERC6927 {
    // Events

    /// @dev Emits when a combo is minted.
    /// @param owner The owner address of the newly minted combo
    /// @param comboId The newly minted combo identifier
    event ComboMinted(address indexed owner, uint256 indexed comboId);

    /// @dev Emits when a combo is dismantled.
    /// @param owner The owner address of the combo
    /// @param comboId The dismantled combo identifier
    event ComboDismantled(address indexed owner, uint256 indexed comboId);

    // Structs

    /// @dev A ComboFactor defines the requirements for NFTs from a specific collection
    /// to participate in the combo and the rules that apply.
    /// A customized combination rule consists of several ComboFactors.
    /// @param lockTokens Indicates if tokens from the collection will be locked when minting a combo
    /// @param maxAllowed Maximum number of NFTs allowed from the collection
    /// @param minRequired Minimum number of NFTs required from the collection
    /// @param maxReuseCount Maximum total reuse count of a token from the collection in
    /// this combo collection (only applicable for ERC-721 and when lockTokens is false)
    /// @param collectionAddress The NFT collection address
    struct ComboFactor {
        bool lockTokens;
        uint24 maxAllowed;
        uint24 minRequired;
        uint64 maxReuseCount;
        address collectionAddress;
    }

    /// @param tokenAddress The NFT's collection address
    /// @param tokenId The NFT identifier
    /// @param amount The number of NFTs with `tokenId` used
    struct Component {
        address tokenAddress;
        uint256 tokenId;
        uint256 amount;
    }

    // Functions

    /// @dev Mints a combo using the provided NFTs as components.
    /// If a combo rule specifies an NFT to be locked, it will be locked within the combo.
    /// For unlocked NFTs, their reuse count will be reduced accordingly.
    /// @param components The NFTs used to mint a combo
    /// @param hash The hash representing user-specific adjustments or
    /// operations applied to the final NFT's visual appearance when fusing NFTs. This
    /// value provides additional information about the unique combination of NFTs.
    function mint(
        Component[] calldata components,
        string calldata hash
    ) external;

    /// @dev Dismantles a combo, returning locked NFTs to the current owner of the combo,
    /// and not restoring the reuse count of the participating but unlocked NFTs.
    function dismantle(uint256 comboId) external;

    /// @dev Retrieve the combo rule.
    function getComboRule() external view returns (ComboFactor[] memory);

    /// @dev Retrieve a combo's components.
    function getComponents(
        uint256 comboId
    ) external view returns (Component[] memory);
}
```

### Network

This module tracks relationship between all fused NFTs.

```solidity
// SPDX-License-Identifier: CC0-1.0
pragma solidity ^0.8.10;

interface INFTNetIndexer {
    struct Token {
        address tokenAddress;
        uint256 tokenId;
    }

    /// @dev Check if the `parent` has been directly fused into `child` or not
    function isParent(
        Token calldata parent,
        Token calldata child
    ) external view returns (bool);

    /// @dev Check if the `ancestor` has been fused into `child` or not, including
    /// nested fusions. The `parent` is also an `ancestor`.
    function isAncestor(
        Token calldata ancestor,
        Token calldata child
    ) external view returns (bool);

    /// @dev Check if `a` and `b` have common `parent`s or not
    function isSibling(
        Token calldata a,
        Token calldata b
    ) external view returns (bool, Token[] memory commonParents);

    /// @dev Return all NFTs that have been fused into the `combo`.
    function getParents(
        Token calldata combo
    ) external view returns (Token[] memory components);
}
```

### License

This module checks and updates the license status of NFTs during fusing.

```solidity
// SPDX-License-Identifier: CC0-1.0
pragma solidity ^0.8.10;

import "./INFTNetIndexer.sol";

interface ILicense {
    /// @dev Triggered during fusing
    /// @param combo The new NFT created by fusing
    /// @param components All NFTs used by the fusing
    function onMinted(
        address user,
        INFTNetIndexer.Token calldata combo,
        INFTNetIndexer.Token[] calldata components
    ) external;

    /// @dev Triggered during dismantling
    /// @param combo The new NFT to be dismantled
    function onDismantled(
        address user,
        INFTNetIndexer.Token calldata combo
    ) external;
}
```

## Rationale

Firstly, the process of fusing existing NFTs to create new ones is highly diverse. The current NFT trading market uses a price discovery mechanism dominated by collection floor prices. To facilitate price discovery, it is essential to assign new NFTs created with different combination rules to separate collections. Therefore, we have extended the ERC-721 to support various combination rules.

Secondly, the potential for customizable combination rules is immense, and maintaining simplicity and flexibility is a fundamental principle. Given the current NFT trading market’s price discovery mechanism, which is dominated by collection floor prices, we have positioned the collection as the basic unit of combination factors. Both ERC-721 and [ERC-1155](./eip-1155.md) are supported as combination factors. To avoid over-design, we have added only the most necessary parameters for each combination factor, such as upper and lower bounds and lock settings. Moreover, to prevent users from repeatedly creating combos using the same NFT without locking and destroying the scarcity of new assets, we have added usage limits for NFTs that do not require locking in the combination.

Lastly, fusing NFTs results in an internal structure within combos. These components are distinct from metadata that cannot be read by smart contracts. They can be read by other smart contracts and used in more native on-chain application scenarios, such as smart airdrops and raffles based on different components of combos.

## Backwards Compatibility

This proposal is fully backwards compatible with the existing ERC-721 standard, extending the standard with new functions that do not affect the core functionality.

## Test Cases

Test cases should be developed to cover the following scenarios:

* Minting a valid combo with ERC-721 and/or ERC-1155 NFTs.
* Dismantling a combo and returning locked NFTs to their owners.
* Setting combo rules and ensuring compliance during the minting - - process.
* Approving ERC-721 NFTs for use in combos.
* Querying combo rules and components.

## Reference Implementation 

An implementation of this EIP will be provided upon acceptance of the proposal.

## Security Considerations

This standard introduces some potential security considerations that must be addressed. These include:

* Ownership and permissions: It is crucial to ensure that only the rightful owner of the NFTs can initiate the fusing process. Proper access control and authentication mechanisms must be in place to prevent unauthorized users from fusing tokens they do not own.
* Reentrancy attacks: The fusing process may involve multiple calls to external contracts, potentially leading to reentrancy attacks. Proper security measures, such as reentrancy guards or the Checks-Effects-Interactions pattern, can help mitigate this risk.
* Gas consumption: The fusing process may involve complex computations and multiple contract interactions, leading to potentially high gas costs. Optimizing the fusing process to minimize gas consumption will be essential for ensuring usability and cost-effectiveness.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
